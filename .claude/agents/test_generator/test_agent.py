"""TestAgent - Generates pytest tests for API endpoints."""

from dataclasses import dataclass, field
from pathlib import Path
from typing import Any

from ..base import Agent
from core.code_generator import CodeGenerator
from core.models import EndpointInfo


@dataclass
class GeneratedTest:
    """A single generated test."""

    function_name: str
    code: str
    endpoint: EndpointInfo
    description: str

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary representation."""
        return {
            "function_name": self.function_name,
            "code": self.code,
            "description": self.description,
            "endpoint": self.endpoint.to_dict(),
        }


@dataclass
class TestResult:
    """Result of test generation."""

    tests: list[GeneratedTest] = field(default_factory=list)
    output_file: str = ""
    test_count: int = 0
    endpoints_covered: int = 0

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary representation."""
        return {
            "test_count": self.test_count,
            "endpoints_covered": self.endpoints_covered,
            "output_file": self.output_file,
            "tests": [t.to_dict() for t in self.tests],
        }

    def format_summary(self) -> str:
        """Format as human-readable summary."""
        lines = [
            "Test Generation Summary",
            "-" * 50,
            f"Tests generated: {self.test_count}",
            f"Endpoints covered: {self.endpoints_covered}",
            f"Output file: {self.output_file}",
            "",
            "Generated Tests:",
        ]

        for test in self.tests:
            lines.append(f"  - {test.function_name}")
            lines.append(f"    â””â”€ {test.description}")

        return "\n".join(lines)

    def get_full_test_file(self) -> str:
        """Generate the complete test file content.

        Returns:
            Complete Python test file content.
        """
        header = '''"""Auto-generated API tests.

Generated by TestAgent for API Contract Enforcer.
"""

import pytest
from httpx import AsyncClient, ASGITransport

from services.user_service.main import app


@pytest.fixture
async def client():
    """Create async test client."""
    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://test") as ac:
        yield ac

'''
        test_code = "\n\n".join(test.code for test in self.tests)
        return header + test_code + "\n"


class TestAgent(Agent):
    """Agent responsible for generating pytest tests for endpoints.

    The TestAgent creates test functions for each API endpoint, covering:
    - Successful response status codes
    - Response schema validation
    - Required field presence
    - Basic error handling (404 for missing resources)

    Required Context: SPEC

    Output: TestResult with generated test code.
    """

    def __init__(self) -> None:
        """Initialize the TestAgent."""
        super().__init__("TestAgent")
        self._generator = CodeGenerator()

    def get_required_context_types(self) -> list[str]:
        """Get required context types.

        Returns:
            List containing 'spec'.
        """
        return ["spec"]

    def run(
        self,
        endpoints: list[EndpointInfo],
        output_dir: str | Path | None = None,
        **kwargs: Any,
    ) -> TestResult:
        """Generate tests for the provided endpoints.

        Args:
            endpoints: List of endpoints to generate tests for.
            output_dir: Directory to write test files. If not provided,
                       uses default path.
            **kwargs: Additional arguments (unused).

        Returns:
            TestResult with generated tests.
        """
        if output_dir is None:
            output_dir = Path("tests/generated")

        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)

        result = TestResult()
        result.output_file = str(output_dir / "test_api_endpoints.py")

        for endpoint in endpoints:
            test_code = self._generator.generate_test(endpoint)
            test_name = self._generate_test_name(endpoint)

            test = GeneratedTest(
                function_name=test_name,
                code=test_code,
                endpoint=endpoint,
                description=f"Test {endpoint.method} {endpoint.path}",
            )
            result.tests.append(test)
            result.test_count += 1

        result.endpoints_covered = len(endpoints)

        return result

    def _generate_test_name(self, endpoint: EndpointInfo) -> str:
        """Generate a test function name for an endpoint.

        Args:
            endpoint: The endpoint to generate a name for.

        Returns:
            Test function name.
        """
        method = endpoint.method.lower()
        path_parts = endpoint.path.strip("/").replace("{", "").replace("}", "").split("/")
        name_parts = ["test", method] + path_parts
        return "_".join(name_parts)

    def write_tests(self, result: TestResult, dry_run: bool = False) -> str:
        """Write generated tests to file.

        Args:
            result: TestResult with generated tests.
            dry_run: If True, return content without writing.

        Returns:
            The generated test file content.
        """
        content = result.get_full_test_file()

        if not dry_run and result.output_file:
            output_path = Path(result.output_file)
            output_path.parent.mkdir(parents=True, exist_ok=True)
            output_path.write_text(content)

        return content

    def format_output(self) -> str:
        """Format the test result for display.

        Returns:
            Human-readable test generation summary.
        """
        if self._result is None or self._result.output is None:
            return f"{self.name}: No tests generated"

        result: TestResult = self._result.output
        return result.format_summary()
